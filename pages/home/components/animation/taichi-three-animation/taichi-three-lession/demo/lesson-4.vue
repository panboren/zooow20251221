<template>
  <div class="lesson-page">
    <div class="content-area">
      <div class="lesson-info">
        <div class="lesson-header">
          <h2>ç¬¬4è¯¾ï¼šTaichi.js å­—æ®µç³»ç»Ÿè¯¦è§£</h2>
          <span class="lesson-tag">å…¥é—¨</span>
        </div>

        <div class="section">
          <h3>ğŸ“š å­¦ä¹ ç›®æ ‡</h3>
          <ul>
            <li>æ·±å…¥ç†è§£ Taichi.js å­—æ®µï¼ˆFieldï¼‰çš„æ¦‚å¿µå’Œä½œç”¨</li>
            <li>å­¦ä¹ æ ‡é‡å­—æ®µã€å‘é‡å­—æ®µã€çŸ©é˜µå­—æ®µçš„ä½¿ç”¨</li>
            <li>ç†è§£å­—æ®µçš„å¤šç»´ç´¢å¼•å’Œè®¿é—®æ–¹å¼</li>
            <li>æŒæ¡å­—æ®µåœ¨ GPU å†…å­˜ä¸­çš„å­˜å‚¨å’Œè®¿é—®</li>
          </ul>
        </div>

        <div class="section">
          <h3>ğŸ¯ ä»€ä¹ˆæ˜¯å­—æ®µï¼ˆFieldï¼‰ï¼Ÿ</h3>
          <p>
            <strong>å­—æ®µ</strong>
            æ˜¯ Taichi.js ä¸­çš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œå­˜å‚¨åœ¨ GPU æ˜¾å­˜ä¸­ã€‚ å¯ä»¥æŠŠå®ƒç†è§£ä¸º"GPU
            ä¸Šçš„æ•°ç»„"ï¼Œä½†æ¯”æ™®é€šæ•°ç»„æ›´å¼ºå¤§ã€æ›´é«˜æ•ˆã€‚
          </p>
          <div class="highlight-box">
            <strong>å­—æ®µçš„ç‰¹ç‚¹ï¼š</strong>
            <ul>
              <li>
                ğŸ“¦
                <strong>GPU æ˜¾å­˜å­˜å‚¨</strong>
                ï¼šæ•°æ®ç›´æ¥å­˜å‚¨åœ¨ GPU ä¸Šï¼Œé¿å…é¢‘ç¹ä¼ è¾“
              </li>
              <li>
                âš¡
                <strong>å¹¶è¡Œè®¿é—®</strong>
                ï¼šGPU å¯ä»¥åŒæ—¶è®¿é—®å¤šä¸ªå­—æ®µå…ƒç´ 
              </li>
              <li>
                ğŸ¯
                <strong>ç±»å‹å®‰å…¨</strong>
                ï¼šæ¯ä¸ªå­—æ®µæœ‰æ˜ç¡®çš„ç±»å‹å®šä¹‰
              </li>
              <li>
                ğŸ“
                <strong>å¤šç»´æ”¯æŒ</strong>
                ï¼šæ”¯æŒ 1Dã€2Dã€3D ç”šè‡³æ›´é«˜ç»´åº¦
              </li>
            </ul>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ“– å­—æ®µç±»å‹</h3>
          <div class="field-types">
            <div class="type-card scalar">
              <h4>1. æ ‡é‡å­—æ®µ</h4>
              <p>å­˜å‚¨å•ä¸ªæ•°å€¼ï¼ˆæ•´æ•°æˆ–æµ®ç‚¹æ•°ï¼‰</p>
              <pre><code>// 1D æ ‡é‡å­—æ®µï¼š1000 ä¸ªæµ®ç‚¹æ•°
let f = ti.field(ti.f32, 1000)

// è®¿é—®
f[0] = 42.0
let x = f[0]  // 42.0</code></pre>
            </div>

            <div class="type-card vector">
              <h4>2. å‘é‡å­—æ®µ</h4>
              <p>å­˜å‚¨å‘é‡ï¼ˆå¦‚ 2Dã€3D ä½ç½®ï¼‰</p>
              <pre><code>// 1D å‘é‡å­—æ®µï¼š1000 ä¸ª 3D å‘é‡
let v = ti.Vector.field(3, ti.f32, 1000)

// è®¿é—®ï¼ˆç±»ä¼¼æ•°ç»„ï¼‰
v[0] = [1.0, 2.0, 3.0]
let pos = v[0]  // [1.0, 2.0, 3.0]

// è®¿é—®å‘é‡åˆ†é‡
v[0].x = 1.0
v[0].y = 2.0
v[0].z = 3.0</code></pre>
            </div>

            <div class="type-card matrix">
              <h4>3. çŸ©é˜µå­—æ®µ</h4>
              <p>å­˜å‚¨çŸ©é˜µï¼ˆå¦‚å˜æ¢çŸ©é˜µï¼‰</p>
              <pre><code>// 1D çŸ©é˜µå­—æ®µï¼š1000 ä¸ª 2x2 çŸ©é˜µ
let m = ti.Matrix.field(2, 2, ti.f32, 1000)

// è®¿é—®
m[0] = [[1.0, 0.0],
          [0.0, 1.0]]</code></pre>
            </div>

            <div class="type-card multidim">
              <h4>4. å¤šç»´å­—æ®µ</h4>
              <p>æ”¯æŒ 2Dã€3D ç­‰å¤šç»´æ•°ç»„</p>
              <pre><code>// 2D æ ‡é‡å­—æ®µï¼š100x100 ç½‘æ ¼
let grid = ti.field(ti.f32, [100, 100])

// è®¿é—® 2D ç´¢å¼•
grid[10, 20] = 5.0
let val = grid[10, 20]  // 5.0

// 2D å‘é‡å­—æ®µï¼ˆæ¯ä¸ªæ ¼ç‚¹ä¸€ä¸ª 3D å‘é‡ï¼‰
let vectorGrid = ti.Vector.field(3, ti.f32, [100, 100])
vectorGrid[10, 20] = [1.0, 2.0, 3.0]</code></pre>
            </div>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ’» ä»£ç ç¤ºä¾‹ï¼šç²’å­ç³»ç»Ÿä½¿ç”¨å­—æ®µ</h3>
          <div class="code-demo">
            <pre><code>// å®šä¹‰ç²’å­æ•°é‡
const N = 10000

// åˆ›å»ºå­—æ®µï¼šä½ç½®ã€é€Ÿåº¦ã€é¢œè‰²
let positions = ti.Vector.field(3, ti.f32, [N])
let velocities = ti.Vector.field(3, ti.f32, [N])
let colors = ti.Vector.field(3, ti.f32, [N])

// æ·»åŠ åˆ°å†…æ ¸ä½œç”¨åŸŸ
ti.addToKernelScope({ positions, velocities, colors, N })

// åˆå§‹åŒ–å†…æ ¸
let init = ti.kernel(() => {
  for (let i of ti.range(N)) {
    // éšæœºä½ç½®
    positions[i] = [ti.random() * 6 - 3, 
                   ti.random() * 6 - 3, 
                   ti.random() * 6 - 3]
    // éšæœºé€Ÿåº¦
    velocities[i] = [0, 0.01, 0]
    // éšæœºé¢œè‰²ï¼ˆç»¿è‰²ç³»ï¼‰
    colors[i] = [0.0, 1.0, ti.random() * 0.3 + 0.5]
  }
})

// æ›´æ–°å†…æ ¸
let update = ti.kernel(() => {
  for (let i of ti.range(N)) {
    // æ›´æ–°ä½ç½®
    positions[i] += velocities[i]
    
    // è¾¹ç•Œåå¼¹
    if (positions[i].y < -3) {
      velocities[i].y *= -1
    }
  }
})

// æ‰§è¡Œ
await init()
// ç„¶ååœ¨æ¯ä¸€å¸§æ‰§è¡Œ update()</code></pre>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ§ª äº’åŠ¨æ¼”ç¤º</h3>
          <div class="demo-container">
            <div class="demo-controls">
              <label>
                ç½‘æ ¼å¤§å°: {{ gridSize }}x{{ gridSize }}
                <input
                  v-model.number="gridSize"
                  type="range"
                  min="10"
                  max="100"
                  step="10"
                  @change="initGrid"
                />
              </label>
              <label>
                æ˜¾ç¤ºæ¨¡å¼:
                <select v-model="displayMode">
                  <option value="density">å¯†åº¦</option>
                  <option value="x">X åˆ†é‡</option>
                  <option value="y">Y åˆ†é‡</option>
                  <option value="z">Z åˆ†é‡</option>
                </select>
              </label>
              <button @click="animateGrid">{{ isAnimating ? 'æš‚åœ' : 'åŠ¨ç”»' }}</button>
            </div>
            <div ref="canvasContainer" class="demo-canvas-container"></div>
            <div class="demo-info">
              <p>
                çŠ¶æ€:
                <span :class="statusClass">{{ status }}</span>
              </p>
              <p>ç½‘æ ¼ç‚¹æ•°: {{ gridSize * gridSize }}</p>
            </div>
          </div>
        </div>

        <div class="section">
          <h3>ğŸš€ ä¸‹ä¸€æ­¥</h3>
          <p>å®Œæˆæœ¬è¯¾åï¼Œæ‚¨å°†äº†è§£ï¼š</p>
          <ul>
            <li>âœ… Taichi.js å­—æ®µç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µ</li>
            <li>âœ… å¦‚ä½•åˆ›å»ºå’Œä½¿ç”¨ä¸åŒç±»å‹çš„å­—æ®µ</li>
            <li>âœ… å­—æ®µåœ¨ GPU è®¡ç®—ä¸­çš„é‡è¦ä½œç”¨</li>
          </ul>
          <p class="next-lesson">
            ä¸‹ä¸€è¯¾å°†å­¦ä¹  GPU è®¡ç®—ä¸æ•°æ®ä¼ è¾“ï¼Œäº†è§£å¦‚ä½•é«˜æ•ˆåœ°å°†æ•°æ®ä» GPU ä¼ è¾“åˆ°æ¸²æŸ“å±‚ã€‚
          </p>
        </div>
      </div>

      <div class="navigation">
        <button class="nav-btn prev" @click="goToPrev">â† ç¬¬3è¯¾ï¼šç¬¬ä¸€ä¸ªç²’å­ç³»ç»Ÿ</button>
        <button class="nav-btn next" @click="goToNext">ç¬¬5è¯¾ï¼šGPU è®¡ç®—ä¸æ•°æ®ä¼ è¾“ â†’</button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue'
import * as THREE from 'three'
import * as ti from 'taichi.js'

// Demo æ§åˆ¶å‚æ•°
const gridSize = ref(30)
const displayMode = ref('density')
const isAnimating = ref(true)
const status = ref('åˆå§‹åŒ–ä¸­...')

const canvasContainer = ref<HTMLElement>()
const statusClass = computed(() => {
  if (status.value === 'è¿è¡Œä¸­') return 'running'
  if (status.value === 'å·²æš‚åœ') return 'paused'
  if (status.value === 'é”™è¯¯') return 'error'
  return 'idle'
})

// Three.js å˜é‡
let scene: THREE.Scene
let camera: THREE.PerspectiveCamera
let renderer: THREE.WebGLRenderer
let gridMesh: THREE.Mesh

// Taichi.js å˜é‡
let tiGrid: any = null
let tiTime: any = null
let tiUpdate: any = null
let size = 30
let time = 0

// åˆå§‹åŒ– Three.js åœºæ™¯
function initThreeJS() {
  const width = canvasContainer.value!.clientWidth || 800
  const height = 400

  scene = new THREE.Scene()
  scene.background = new THREE.Color(0x0a0a1a)

  camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000)
  camera.position.z = 15
  camera.position.y = 5
  camera.lookAt(0, 0, 0)

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
  renderer.setSize(width, height)
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
  canvasContainer.value!.appendChild(renderer.domElement)
}

// åˆå§‹åŒ– Taichi.js å­—æ®µç½‘æ ¼
async function initTaichi() {
  try {
    await ti.init()

    // ä½¿ç”¨å±€éƒ¨å˜é‡é¿å…é—­åŒ…é—®é¢˜
    const newSize = gridSize.value
    size = newSize

    // åˆ›å»º 2D å‘é‡å­—æ®µï¼šæ¯ä¸ªç½‘æ ¼ç‚¹ä¸€ä¸ª 3D å‘é‡
    tiGrid = ti.Vector.field(3, ti.f32, [size, size])
    tiTime = ti.field(ti.f32, [1]) // æ ‡é‡å­—æ®µï¼Œç”¨äºå­˜å‚¨æ—¶é—´

    ti.addToKernelScope({ tiGrid, tiTime, size })

    // åˆå§‹åŒ–å†…æ ¸ï¼šåˆ›å»ºæ³¢åŠ¨æ•ˆæœ
    tiUpdate = ti.kernel(() => {
      tiTime[0] += 0.02
      let t = tiTime[0]

      for (let x of ti.range(size)) {
        for (let y of ti.range(size)) {
          // ä½¿ç”¨æ­£å¼¦æ³¢åˆ›å»ºåŠ¨æ€æ•ˆæœ
          let fx = (x / size) * 4.0
          let fy = (y / size) * 4.0
          tiGrid[[x, y]] = [
            ti.sin(fx + t) * 0.5 + 0.5,
            ti.sin(fy + t) * 0.5 + 0.5,
            ti.sin(fx + fy + t * 2) * 0.5 + 0.5
          ]
        }
      }
    })

    // æ‰§è¡Œä¸€æ¬¡åˆå§‹åŒ–
    await tiUpdate()
    status.value = 'è¿è¡Œä¸­'
  } catch (error) {
    console.error('Taichi.js åˆå§‹åŒ–å¤±è´¥:', error)
    status.value = 'Taichi.js ä¸å¯ç”¨'
    tiUpdate = null
  }
}

// åˆ›å»º Three.js ç½‘æ ¼
function createGrid() {
  const geometry = new THREE.PlaneGeometry(10, 10, size - 1, size - 1)

  // åˆ›å»ºé¡¶ç‚¹é¢œè‰²å±æ€§ - é¡¶ç‚¹æ•°é‡æ˜¯ size * size
  const vertexCount = geometry.attributes.position.count
  const colors = new Float32Array(vertexCount * 3)
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))

  const material = new THREE.MeshBasicMaterial({
    vertexColors: true,
    wireframe: true,
    side: THREE.DoubleSide
  })

  gridMesh = new THREE.Mesh(geometry, material)
  gridMesh.rotation.x = -Math.PI / 2
  scene.add(gridMesh)

  console.log(`åˆ›å»ºç½‘æ ¼: size=${size}, é¡¶ç‚¹æ•°=${vertexCount}, æœŸæœ›=${size * size}`)
}

// æ›´æ–°ç½‘æ ¼é¢œè‰²
async function updateGrid() {
  if (!tiUpdate || !gridMesh) return

  try {
    await tiUpdate()

    // ä» GPU è¯»å–æ•°æ® - gridData æ˜¯ 2D æ•°ç»„
    const gridData = await tiGrid.toArray()

    // æ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œäº†è§£æ•°æ®ç»“æ„
    if (gridData.length > 0 && gridData[0]) {
      console.log('gridData[0][0]:', gridData[0][0])
      console.log('gridData[0] é•¿åº¦:', gridData[0].length)
    }

    // æ›´æ–° Three.js ç½‘æ ¼é¢œè‰²
    const colors = gridMesh.geometry.attributes.color

    // æ·»åŠ è¾¹ç•Œæ£€æŸ¥
    const dataRows = gridData.length
    const dataCols = dataRows > 0 ? gridData[0].length : 0

    console.log(`æ•°æ®å°ºå¯¸: ${dataRows}x${dataCols}, æœŸæœ›: ${size}x${size}`)

    // éå†æ‰€æœ‰ç½‘æ ¼ç‚¹
    for (let x = 0; x < Math.min(size, dataRows); x++) {
      for (let y = 0; y < Math.min(size, dataCols); y++) {
        // Taichi.js 2D å­—æ®µ: gridData[x][y]
        const vector = gridData[x][y]

        // è·³è¿‡æ— æ•ˆæ•°æ®
        if (!vector) {
          continue
        }

        // Three.js é¡¶ç‚¹ç´¢å¼• (åˆ—ä¼˜å…ˆ: x + size * y)
        const vertexIndex = x + size * y

        // å®‰å…¨è®¿é—® vector çš„å…ƒç´ 
        const vx = vector[0] !== undefined ? vector[0] : 0
        const vy = vector[1] !== undefined ? vector[1] : 0
        const vz = vector[2] !== undefined ? vector[2] : 0

        let r, g, b
        if (displayMode.value === 'density') {
          r = vx
          g = vy
          b = vz
        } else if (displayMode.value === 'x') {
          r = g = b = vx
        } else if (displayMode.value === 'y') {
          r = g = b = vy
        } else if (displayMode.value === 'z') {
          r = g = b = vz
        }

        colors.setXYZ(vertexIndex, r, g, b)
      }
    }

    colors.needsUpdate = true
  } catch (error) {
    console.error('æ›´æ–°å¤±è´¥:', error)
    status.value = 'é”™è¯¯'
  }
}

// åŠ¨ç”»å¾ªç¯
function animate() {
  if (isAnimating.value) {
    updateGrid()
  }

  if (renderer && scene && camera) {
    renderer.render(scene, camera)
  }

  requestAnimationFrame(animate)
}

// é‡æ–°åˆå§‹åŒ–ç½‘æ ¼
async function initGrid() {
  size = gridSize.value

  if (gridMesh) {
    scene.remove(gridMesh)
    // å®‰å…¨é‡Šæ”¾å‡ ä½•ä½“
    if (gridMesh.geometry && typeof gridMesh.geometry.dispose === 'function') {
      gridMesh.geometry.dispose()
    }
    // å®‰å…¨é‡Šæ”¾æè´¨
    if (gridMesh.material && typeof gridMesh.material.dispose === 'function') {
      gridMesh.material.dispose()
    }
  }

  await initTaichi()
  createGrid()

  // åˆå§‹æ›´æ–°ä¸€æ¬¡
  await updateGrid()
}

// åˆ‡æ¢åŠ¨ç”»
function animateGrid() {
  isAnimating.value = !isAnimating.value
  status.value = isAnimating.value ? 'è¿è¡Œä¸­' : 'å·²æš‚åœ'
}

function goToPrev() {
  window.location.reload()
}

function goToNext() {
  alert('ç¬¬5è¯¾å³å°†æ¨å‡ºï¼')
}

onMounted(async () => {
  initThreeJS()
  await initTaichi()
  createGrid()
  await updateGrid()
  animate()
})

onUnmounted(() => {
  if (gridMesh) {
    scene.remove(gridMesh)
    if (gridMesh.geometry && typeof gridMesh.geometry.dispose === 'function') {
      gridMesh.geometry.dispose()
    }
    if (gridMesh.material && typeof gridMesh.material.dispose === 'function') {
      gridMesh.material.dispose()
    }
  }
  if (renderer) {
    renderer.dispose()
  }
})
</script>

<style scoped lang="scss">
.lesson-page {
  min-height: 100vh;
  background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
  padding: 80px 30px 30px 30px;
  color: white;
}

.content-area {
  max-width: 900px;
  margin: 0 auto;
}

.lesson-info {
  .lesson-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 30px;

    h2 {
      margin: 0;
      font-size: 32px;
      color: #00ff88;
    }

    .lesson-tag {
      padding: 6px 15px;
      background: rgba(0, 255, 136, 0.2);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 20px;
      font-size: 13px;
      color: #00ff88;
    }
  }

  .section {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 25px;
    border: 1px solid rgba(255, 255, 255, 0.08);

    h3 {
      margin: 0 0 15px 0;
      font-size: 22px;
      color: #00aaff;
    }

    p {
      font-size: 15px;
      line-height: 1.7;
      color: rgba(255, 255, 255, 0.85);
      margin-bottom: 15px;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;

      li {
        padding: 8px 0 8px 25px;
        position: relative;
        font-size: 15px;
        line-height: 1.6;
        color: rgba(255, 255, 255, 0.85);

        &:before {
          content: 'â–¸';
          position: absolute;
          left: 0;
          color: #00ff88;
        }
      }
    }
  }

  .highlight-box {
    background: rgba(255, 200, 0, 0.1);
    border-left: 4px solid rgba(255, 200, 0, 0.6);
    padding: 15px 20px;
    border-radius: 8px;
    margin: 20px 0;

    strong {
      color: #ffc800;
      font-size: 16px;
    }

    ul li:before {
      color: #ffc800;
    }
  }

  .field-types {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin: 20px 0;

    .type-card {
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(0, 170, 255, 0.2);
      border-radius: 10px;
      padding: 15px;

      &.scalar {
        border-color: rgba(100, 200, 255, 0.4);
      }
      &.vector {
        border-color: rgba(100, 255, 100, 0.4);
      }
      &.matrix {
        border-color: rgba(255, 200, 100, 0.4);
      }
      &.multidim {
        border-color: rgba(255, 100, 200, 0.4);
      }

      h4 {
        margin: 0 0 10px 0;
        font-size: 16px;
        color: #88ccff;
      }

      p {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.7);
      }

      pre {
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 6px;
        overflow-x: auto;
        margin: 0;

        code {
          font-family: 'Courier New', monospace;
          font-size: 11px;
          line-height: 1.4;
          color: #aaffaa;
        }
      }
    }
  }

  .code-demo {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(0, 255, 136, 0.2);
    border-radius: 12px;
    padding: 20px;

    pre {
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;

      code {
        font-family: 'Courier New', monospace;
        font-size: 12px;
        line-height: 1.6;
        color: #aaffaa;
      }
    }
  }

  .demo-container {
    background: rgba(0, 50, 100, 0.15);
    border: 1px solid rgba(0, 170, 255, 0.2);
    border-radius: 12px;
    padding: 25px;

    .demo-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
      align-items: center;

      label {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;

        input[type='range'],
        select {
          cursor: pointer;
          padding: 5px;
          background: rgba(0, 0, 0, 0.3);
          border: 1px solid rgba(0, 255, 136, 0.4);
          border-radius: 5px;
          color: white;
        }
      }

      button {
        padding: 10px 20px;
        background: rgba(0, 255, 136, 0.2);
        border: 1px solid rgba(0, 255, 136, 0.4);
        border-radius: 8px;
        color: #00ff88;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;

        &:hover {
          background: rgba(0, 255, 136, 0.3);
        }
      }
    }

    .demo-canvas-container {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin-bottom: 15px;
      overflow: hidden;
    }

    .demo-info {
      p {
        font-size: 14px;
        margin-bottom: 5px;

        .running {
          color: #00ff88;
          font-weight: bold;
        }
        .paused {
          color: #ffaa00;
          font-weight: bold;
        }
        .error {
          color: #ff4444;
          font-weight: bold;
        }
        .idle {
          color: rgba(255, 255, 255, 0.7);
        }
      }
    }
  }

  .next-lesson {
    padding: 15px;
    background: rgba(0, 255, 136, 0.1);
    border-left: 3px solid #00ff88;
    border-radius: 6px;
    font-style: italic;
    color: rgba(255, 255, 255, 0.8);
  }
}

.navigation {
  display: flex;
  justify-content: space-between;
  margin-top: 30px;

  .nav-btn {
    padding: 12px 25px;
    background: rgba(0, 170, 255, 0.2);
    border: 1px solid rgba(0, 170, 255, 0.3);
    border-radius: 8px;
    color: #00aaff;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;

    &:hover {
      background: rgba(0, 170, 255, 0.3);
      transform: translateX(-2px);
    }

    &.next:hover {
      transform: translateX(2px);
    }
  }
}
</style>
