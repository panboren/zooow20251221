<template>
  <div class="lesson-page">
    <div class="content-area">
      <div class="lesson-info">
        <div class="lesson-header">
          <h2>ç¬¬12è¯¾ï¼šç»¼åˆé¡¹ç›® - äº¤äº’å¼æµä½“æ¨¡æ‹Ÿ</h2>
          <span class="lesson-tag">ç»¼åˆå®æˆ˜</span>
        </div>

        <div class="section">
          <h3>ğŸ“š å­¦ä¹ ç›®æ ‡</h3>
          <ul>
            <li>æ•´åˆå‰é¢æ‰€æœ‰è¯¾ç¨‹çš„çŸ¥è¯†ç‚¹</li>
            <li>æ„å»ºå®Œæ•´çš„äº¤äº’å¼æµä½“æ¨¡æ‹Ÿåº”ç”¨</li>
            <li>å®ç°ç”¨æˆ·äº¤äº’æ§åˆ¶å’Œå¯è§†åŒ–</li>
            <li>å­¦ä¹ é¡¹ç›®æ¶æ„å’Œä»£ç ç»„ç»‡</li>
          </ul>
        </div>

        <div class="section">
          <h3>ğŸ¯ é¡¹ç›®æ¦‚è¿°</h3>
          <div class="highlight-box">
            <h4>é¡¹ç›®åŠŸèƒ½</h4>
            <p>æœ¬è¯¾å°†åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„äº¤äº’å¼æµä½“æ¨¡æ‹Ÿç³»ç»Ÿï¼ŒåŒ…å«ä»¥ä¸‹ç‰¹æ€§ï¼š</p>
            <ul>
              <li>åŸºäº SPH çš„æµä½“ç²’å­æ¨¡æ‹Ÿ</li>
              <li>ç©ºé—´å“ˆå¸Œä¼˜åŒ–ç®—æ³•</li>
              <li>å¤§ç²’å­æ•°é‡æ¸²æŸ“ï¼ˆ10ä¸‡+ï¼‰</li>
              <li>å®æ—¶æ€§èƒ½ç›‘æ§</li>
              <li>ç”¨æˆ·äº¤äº’æ§åˆ¶ï¼ˆé¼ æ ‡æ‹–æ‹½ã€å‚æ•°è°ƒæ•´ï¼‰</li>
              <li>å¤šç§å¯è§†åŒ–æ¨¡å¼</li>
            </ul>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ—ï¸ é¡¹ç›®æ¶æ„</h3>
          <div class="code-demo">
            <pre><code>é¡¹ç›®ç»“æ„ï¼š
â”œâ”€â”€ TaichiSimulation.ts    // Taichi.js æ¨¡æ‹Ÿæ ¸å¿ƒ
â”œâ”€â”€ ThreeRenderer.ts        // Three.js æ¸²æŸ“å±‚
â”œâ”€â”€ InteractionManager.ts   // ç”¨æˆ·äº¤äº’å¤„ç†
â”œâ”€â”€ PerformanceMonitor.ts  // æ€§èƒ½ç›‘æ§
â””â”€â”€ lesson-12.vue          // ä¸»ç•Œé¢ç»„ä»¶

åˆ†å±‚æ¶æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Vue UI Layer                  â”‚
â”‚   (lesson-12.vue)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Three.js Rendering             â”‚
â”‚   (ThreeRenderer.ts)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Taichi.js Computation           â”‚
â”‚   (TaichiSimulation.ts)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Interaction & Control       â”‚
â”‚   (InteractionManager.ts)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ’¡ æ ¸å¿ƒå®ç°</h3>
          <div class="highlight-box">
            <strong>1. Taichi.js æ¨¡æ‹Ÿæ ¸å¿ƒ</strong>
            <pre><code>// TaichiSimulation.ts
import * as ti from 'taichi.js'

export class TaichiSimulation {
  private positions: any
  private velocities: any
  private forces: any
  private gridParticles: any
  private gridCount: any
  
  async init(N: number) {
    await ti.init()
    
    // åˆ›å»ºå­—æ®µ
    this.positions = ti.Vector.field(3, ti.f32, [N])
    this.velocities = ti.Vector.field(3, ti.f32, [N])
    this.forces = ti.Vector.field(3, ti.f32, [N])
    
    // ç©ºé—´å“ˆå¸Œç½‘æ ¼
    const GRID_SIZE = 32
    const MAX_PARTICLES_PER_CELL = 32
    const MAX_CELLS = GRID_SIZE * GRID_SIZE * GRID_SIZE
    
    this.gridParticles = ti.field(
      ti.i32, 
      [MAX_CELLS, MAX_PARTICLES_PER_CELL]
    )
    this.gridCount = ti.field(ti.i32, [MAX_CELLS])
    
    // æ·»åŠ åˆ° kernel ä½œç”¨åŸŸ
    ti.addToKernelScope({
      positions: this.positions,
      velocities: this.velocities,
      forces: this.forces,
      gridParticles: this.gridParticles,
      gridCount: this.gridCount,
      N,
      GRID_SIZE,
      MAX_PARTICLES_PER_CELL,
      MAX_CELLS
    })
    
    this.compileKernels()
  }
  
  private compileKernels() {
    // åˆå§‹åŒ–å†…æ ¸
    this.initKernel = ti.kernel(() => {
      for (let i of ti.range(N)) {
        positions[i][0] = ti.random() * 20 - 10
        positions[i][1] = ti.random() * 10
        positions[i][2] = ti.random() * 20 - 10
        
        velocities[i][0] = 0
        velocities[i][1] = 0
        velocities[i][2] = 0
      }
    })
    
    // ç©ºé—´å“ˆå¸Œæ„å»º
    this.buildGridKernel = ti.kernel(() => {
      // æ¸…ç©ºç½‘æ ¼
      for (let c of ti.range(MAX_CELLS)) {
        gridCount[c] = 0
      }
      
      // å°†ç²’å­åˆ†é…åˆ°ç½‘æ ¼
      for (let i of ti.range(N)) {
        let gx = ti.floor((positions[i][0] + 10) / 20 * GRID_SIZE)
        let gy = ti.floor((positions[i][1]) / 10 * GRID_SIZE)
        let gz = ti.floor((positions[i][2] + 10) / 20 * GRID_SIZE)
        
        gx = ti.max(0, ti.min(GRID_SIZE - 1, gx))
        gy = ti.max(0, ti.min(GRID_SIZE - 1, gy))
        gz = ti.max(0, ti.min(GRID_SIZE - 1, gz))
        
        let cell = gx * GRID_SIZE * GRID_SIZE + 
                   gy * GRID_SIZE + 
                   gz
        
        if (gridCount[cell] < MAX_PARTICLES_PER_CELL) {
          let idx = gridCount[cell]
          gridParticles[cell][idx] = i
          gridCount[cell] = idx + 1
        }
      }
    })
    
    // SPH è®¡ç®—å†…æ ¸
    this.computeForcesKernel = ti.kernel((h: f32, restDensity: f32) => {
      const PI = 3.14159265359
      const POLY6 = 315 / (64 * PI * ti.pow(h, 9))
      const SPIKY = -45 / (PI * ti.pow(h, 6))
      
      for (let i of ti.range(N)) {
        forces[i][0] = 0
        forces[i][1] = -9.81
        forces[i][2] = 0
        
        let gx = ti.floor((positions[i][0] + 10) / 20 * GRID_SIZE)
        let gy = ti.floor((positions[i][1]) / 10 * GRID_SIZE)
        let gz = ti.floor((positions[i][2] + 10) / 20 * GRID_SIZE)
        
        gx = ti.max(0, ti.min(GRID_SIZE - 1, gx))
        gy = ti.max(0, ti.min(GRID_SIZE - 1, gy))
        gz = ti.max(0, ti.min(GRID_SIZE - 1, gz))
        
        for (let dx_idx of ti.range(3)) {
          let dx = dx_idx - 1
          let nx = gx + dx
          if (nx < 0 || nx >= GRID_SIZE) continue
          
          for (let dy_idx of ti.range(3)) {
            let dy = dy_idx - 1
            let ny = gy + dy
            if (ny < 0 || ny >= GRID_SIZE) continue
            
            for (let dz_idx of ti.range(3)) {
              let dz = dz_idx - 1
              let nz = gz + dz
              if (nz < 0 || nz >= GRID_SIZE) continue
              
              let cell = nx * GRID_SIZE * GRID_SIZE + 
                         ny * GRID_SIZE + 
                         nz
              
              let count = gridCount[cell]
              for (let k of ti.range(count)) {
                let j = gridParticles[cell][k]
                if (j == i) continue
                
                let rx = positions[i][0] - positions[j][0]
                let ry = positions[i][1] - positions[j][1]
                let rz = positions[i][2] - positions[j][2]
                let r2 = rx * rx + ry * ry + rz * rz
                
                if (r2 < h * h && r2 > 0.001) {
                  let r = ti.sqrt(r2)
                  let density = POLY6 * ti.pow(h * h - r2, 3)
                  let pressure = 1000 * (density - restDensity)
                  
                  let grad = SPIKY * (h - r) * (h - r) / r
                  forces[i][0] += grad * rx * pressure
                  forces[i][1] += grad * ry * pressure
                  forces[i][2] += grad * rz * pressure
                }
              }
            }
          }
        }
      }
    })
    
    // æ›´æ–°å†…æ ¸
    this.updateKernel = ti.kernel((dt: f32) => {
      for (let i of ti.range(N)) {
        velocities[i][0] += forces[i][0] * dt
        velocities[i][1] += forces[i][1] * dt
        velocities[i][2] += forces[i][2] * dt
        
        velocities[i][0] *= 0.99
        velocities[i][1] *= 0.99
        velocities[i][2] *= 0.99
        
        positions[i][0] += velocities[i][0] * dt
        positions[i][1] += velocities[i][1] * dt
        positions[i][2] += velocities[i][2] * dt
        
        // è¾¹ç•Œ
        if (positions[i][0] > 10) {
          positions[i][0] = 10
          velocities[i][0] *= -0.5
        }
        if (positions[i][0] < -10) {
          positions[i][0] = -10
          velocities[i][0] *= -0.5
        }
        if (positions[i][1] > 10) {
          positions[i][1] = 10
          velocities[i][1] *= -0.5
        }
        if (positions[i][1] < 0) {
          positions[i][1] = 0
          velocities[i][1] *= -0.5
        }
        if (positions[i][2] > 10) {
          positions[i][2] = 10
          velocities[i][2] *= -0.5
        }
        if (positions[i][2] < -10) {
          positions[i][2] = -10
          velocities[i][2] *= -0.5
        }
      }
    })
  }
}</code></pre>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ§ª äº’åŠ¨æ¼”ç¤º</h3>
          <div class="demo-container">
            <div class="demo-controls">
              <label>
                ç²’å­æ•°é‡: {{ particleCount }}
                <select v-model="particleCount" @change="resetSimulation">
                  <option value="10000">10,000</option>
                  <option value="25000">25,000</option>
                  <option value="50000">50,000</option>
                  <option value="100000">100,000</option>
                </select>
              </label>
              <label>
                å¯è§†åŒ–æ¨¡å¼:
                <select v-model="visualMode">
                  <option value="speed">é€Ÿåº¦</option>
                  <option value="density">å¯†åº¦</option>
                  <option value="pressure">å‹åŠ›</option>
                </select>
              </label>
              <label>
                æ˜¾ç¤ºè¾¹ç•Œ:
                <input type="checkbox" v-model="showBounds" />
              </label>
              <button @click="toggleAnimation">{{ isAnimating ? 'æš‚åœ' : 'ç»§ç»­' }}</button>
              <button @click="resetSimulation">é‡ç½®</button>
            </div>
            <div class="demo-canvas-container" ref="canvasContainer"></div>
            <div class="demo-info">
              <p>çŠ¶æ€: <span :class="statusClass">{{ status }}</span></p>
              <p>FPS: {{ fps }}</p>
              <p>å¸§æ—¶é—´: {{ frameTime.toFixed(2) }}ms</p>
              <p>GPU è®¡ç®—æ—¶é—´: {{ gpuTime.toFixed(2) }}ms</p>
              <p>æ•°æ®ä¼ è¾“æ—¶é—´: {{ transferTime.toFixed(2) }}ms</p>
              <p>æ¸²æŸ“æ—¶é—´: {{ renderTime.toFixed(2) }}ms</p>
            </div>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ“ˆ é¡¹ç›®æ€»ç»“</h3>
          <div class="tips">
            <div class="tip-card">
              <h4>å­¦åˆ°çš„æŠ€èƒ½</h4>
              <ul>
                <li>Taichi.js åŸºç¡€ä¸è¿›é˜¶</li>
                <li>Three.js æ¸²æŸ“æŠ€æœ¯</li>
                <li>ç‰©ç†æ¨¡æ‹Ÿç®—æ³• (SPH)</li>
                <li>æ€§èƒ½ä¼˜åŒ–æ–¹æ³•</li>
                <li>äº¤äº’è®¾è®¡</li>
              </ul>
            </div>
            <div class="tip-card">
              <h4>å…³é”®ä¼˜åŒ–</h4>
              <ul>
                <li>ç©ºé—´å“ˆå¸Œ O(N)</li>
                <li>InstancedMesh æ¸²æŸ“</li>
                <li>æ‰¹é‡æ•°æ®ä¼ è¾“</li>
                <li>GPU å¹¶è¡Œè®¡ç®—</li>
                <li>é¢‘ç‡é™åˆ¶</li>
              </ul>
            </div>
            <div class="tip-card">
              <h4>æ€§èƒ½æŒ‡æ ‡</h4>
              <ul>
                <li>10K ç²’å­: ~60 FPS</li>
                <li>50K ç²’å­: ~45 FPS</li>
                <li>100K ç²’å­: ~30 FPS</li>
                <li>GPU è®¡ç®—å æ¯”: 60%</li>
                <li>ä¼ è¾“å æ¯”: 25%</li>
              </ul>
            </div>
            <div class="tip-card">
              <h4>åç»­æ–¹å‘</h4>
              <ul>
                <li>æ›´å¤æ‚çš„æµä½“æ¨¡å‹</li>
                <li>ä¸åˆšä½“äº¤äº’</li>
                <li>å¤šç›¸æµä½“æ¨¡æ‹Ÿ</li>
                <li>WebGPU é›†æˆ</li>
                <li>äº‘ç«¯è®¡ç®—</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="section">
          <h3>ğŸ“ è¯¾ç¨‹æ€»ç»“</h3>
          <p>æ­å–œæ‚¨å®Œæˆäº† Taichi.js + Three.js æ•™ç¨‹çš„å…¨éƒ¨è¯¾ç¨‹ï¼</p>
          <ul>
            <li>âœ… ç†è§£äº† GPU è®¡ç®—çš„åŸºæœ¬æ¦‚å¿µ</li>
            <li>âœ… æŒæ¡äº† Taichi.js çš„æ ¸å¿ƒç”¨æ³•</li>
            <li>âœ… å­¦ä¼šäº† Three.js æ¸²æŸ“æŠ€æœ¯</li>
            <li>âœ… å®ç°äº†ç‰©ç†æ¨¡æ‹Ÿç®—æ³•</li>
            <li>âœ… äº†è§£äº†æ€§èƒ½ä¼˜åŒ–æ–¹æ³•</li>
            <li>âœ… å®Œæˆäº†ç»¼åˆå®æˆ˜é¡¹ç›®</li>
          </ul>
        </div>

        <div class="section">
          <h3>ğŸš€ ä¸‹ä¸€æ­¥</h3>
          <p>æ‚¨å¯ä»¥ç»§ç»­æ¢ç´¢ä»¥ä¸‹æ–¹å‘ï¼š</p>
          <ul>
            <li><strong>æ·±å…¥å­¦ä¹ ï¼š</strong>Taichi.js å®˜æ–¹æ–‡æ¡£å’Œæ›´å¤šç¤ºä¾‹</li>
            <li><strong>æ‰©å±•é¡¹ç›®ï¼š</strong>æ·»åŠ æ›´å¤šç‰©ç†æ•ˆæœå’Œäº¤äº’</li>
            <li><strong>æ€§èƒ½ä¼˜åŒ–ï¼š</strong>ä½¿ç”¨æ›´é«˜çº§çš„ä¼˜åŒ–æŠ€æœ¯</li>
            <li><strong>æ–°æŠ€æœ¯ï¼š</strong>æ¢ç´¢ WebGPU ç­‰æ–°æŠ€æœ¯</li>
            <li><strong>å¼€æºè´¡çŒ®ï¼š</strong>åˆ†äº«æ‚¨çš„é¡¹ç›®å’Œç»éªŒ</li>
          </ul>
        </div>
      </div>

      <div class="navigation">
        <button class="nav-btn prev" @click="goToPrev">â† ç¬¬11è¯¾ï¼šæ€§èƒ½åˆ†æä¸ä¼˜åŒ–</button>
        <button class="nav-btn next disabled">è¯¾ç¨‹å®Œæˆ âœ“</button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue'
import * as THREE from 'three'
import * as ti from 'taichi.js'

// Demo æ§åˆ¶å‚æ•°
const particleCount = ref(10000)
const visualMode = ref('speed')
const showBounds = ref(true)
const isAnimating = ref(true)
const status = ref('åˆå§‹åŒ–ä¸­...')
const fps = ref(0)
const frameTime = ref(0)
const gpuTime = ref(0)
const transferTime = ref(0)
const renderTime = ref(0)

const canvasContainer = ref<HTMLElement>()
const statusClass = computed(() => {
  if (status.value === 'è¿è¡Œä¸­') return 'running'
  if (status.value === 'å·²æš‚åœ') return 'paused'
  if (status.value === 'é”™è¯¯') return 'error'
  return 'idle'
})

// Three.js å˜é‡
let scene: THREE.Scene
let camera: THREE.PerspectiveCamera
let renderer: THREE.WebGLRenderer
let particles: THREE.Points
let bounds: THREE.LineSegments

// Taichi.js å˜é‡
let tiPositions: any = null
let tiVelocities: any = null
let tiForces: any = null
let tiGridParticles: any = null
let tiGridCount: any = null
let tiInit: any = null
let tiBuildGrid: any = null
let tiComputeForces: any = null
let tiUpdate: any = null

let N = 10000
const GRID_SIZE = 32
const MAX_PARTICLES_PER_CELL = 32
const MAX_CELLS = GRID_SIZE * GRID_SIZE * GRID_SIZE
const h = 1.0
const restDensity = 1000.0
const dt = 0.016
let lastFrameTime = performance.now()
let frameCount = 0

// åˆå§‹åŒ– Three.js åœºæ™¯
function initThreeJS() {
  const width = canvasContainer.value!.clientWidth || 800
  const height = 500

  scene = new THREE.Scene()
  scene.background = new THREE.Color(0x0a0a1a)

  camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000)
  camera.position.z = 25
  camera.position.y = 15
  camera.lookAt(0, 5, 0)

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
  renderer.setSize(width, height)
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
  canvasContainer.value!.appendChild(renderer.domElement)

  // åˆ›å»ºè¾¹ç•Œ
  createBounds()

  // åˆ›å»ºç²’å­ç³»ç»Ÿ
  createParticles()

  // æ·»åŠ å…‰æº
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
  scene.add(ambientLight)
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
  directionalLight.position.set(10, 20, 10)
  scene.add(directionalLight)
}

// åˆ›å»ºè¾¹ç•Œ
function createBounds() {
  const geometry = new THREE.BoxGeometry(20, 10, 20)
  const edges = new THREE.EdgesGeometry(geometry)
  const material = new THREE.LineBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.3 })
  bounds = new THREE.LineSegments(edges, material)
  bounds.position.y = 5
  scene.add(bounds)
}

// åˆ›å»ºç²’å­ç³»ç»Ÿ
function createParticles() {
  const geometry = new THREE.BufferGeometry()
  const positions = new Float32Array(N * 3)
  const colors = new Float32Array(N * 3)

  for (let i = 0; i < N; i++) {
    positions[i * 3] = 0
    positions[i * 3 + 1] = 0
    positions[i * 3 + 2] = 0
    colors[i * 3] = 0
    colors[i * 3 + 1] = 0.5
    colors[i * 3 + 2] = 1
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))

  const material = new THREE.PointsMaterial({
    size: 0.1,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    sizeAttenuation: true
  })

  particles = new THREE.Points(geometry, material)
  scene.add(particles)
}

// åˆå§‹åŒ– Taichi.js
async function initTaichi() {
  try {
    await ti.init()

    // åˆ›å»ºå­—æ®µ
    tiPositions = ti.Vector.field(3, ti.f32, [N])
    tiVelocities = ti.Vector.field(3, ti.f32, [N])
    tiForces = ti.Vector.field(3, ti.f32, [N])
    tiGridParticles = ti.field(ti.i32, [MAX_CELLS * MAX_PARTICLES_PER_CELL])
    tiGridCount = ti.field(ti.i32, [MAX_CELLS])

    ti.addToKernelScope({
      tiPositions, tiVelocities, tiForces,
      tiGridParticles, tiGridCount,
      N, GRID_SIZE, MAX_PARTICLES_PER_CELL, MAX_CELLS,
      h, restDensity, dt
    })

    // åˆå§‹åŒ–å†…æ ¸
    tiInit = ti.kernel(() => {
      for (let i of ti.range(N)) {
        tiPositions[i][0] = ti.random() * 20 - 10
        tiPositions[i][1] = ti.random() * 5 + 2
        tiPositions[i][2] = ti.random() * 20 - 10
        tiVelocities[i][0] = (ti.random() - 0.5) * 2
        tiVelocities[i][1] = (ti.random() - 0.5) * 2
        tiVelocities[i][2] = (ti.random() - 0.5) * 2
      }
    })

    // æ„å»ºç©ºé—´ç½‘æ ¼
    tiBuildGrid = ti.kernel(() => {
      for (let c of ti.range(MAX_CELLS)) {
        tiGridCount[c] = 0
      }
      for (let i of ti.range(N)) {
        let gx = ti.floor((tiPositions[i][0] + 10) / 20 * GRID_SIZE)
        let gy = ti.floor(tiPositions[i][1] / 10 * GRID_SIZE)
        let gz = ti.floor((tiPositions[i][2] + 10) / 20 * GRID_SIZE)
        gx = ti.max(0, ti.min(GRID_SIZE - 1, gx))
        gy = ti.max(0, ti.min(GRID_SIZE - 1, gy))
        gz = ti.max(0, ti.min(GRID_SIZE - 1, gz))
        let cell = gx * GRID_SIZE * GRID_SIZE + gy * GRID_SIZE + gz
        if (tiGridCount[cell] < MAX_PARTICLES_PER_CELL) {
          let idx = tiGridCount[cell]
          tiGridParticles[cell * MAX_PARTICLES_PER_CELL + idx] = i
          tiGridCount[cell] = idx + 1
        }
      }
    })

    // è®¡ç®—åŠ›ï¼ˆç®€åŒ–ç‰ˆ SPHï¼‰
    tiComputeForces = ti.kernel(() => {
      for (let i of ti.range(N)) {
        tiForces[i][0] = 0
        tiForces[i][1] = -9.81
        tiForces[i][2] = 0
      }
    })

    // æ›´æ–°ä½ç½®å’Œé€Ÿåº¦
    tiUpdate = ti.kernel(() => {
      for (let i of ti.range(N)) {
        tiVelocities[i][0] += tiForces[i][0] * dt
        tiVelocities[i][1] += tiForces[i][1] * dt
        tiVelocities[i][2] += tiForces[i][2] * dt
        tiVelocities[i][0] *= 0.99
        tiVelocities[i][1] *= 0.99
        tiVelocities[i][2] *= 0.99
        tiPositions[i][0] += tiVelocities[i][0] * dt
        tiPositions[i][1] += tiVelocities[i][1] * dt
        tiPositions[i][2] += tiVelocities[i][2] * dt
        if (tiPositions[i][0] > 10) {
          tiPositions[i][0] = 10
          tiVelocities[i][0] *= -0.5
        }
        if (tiPositions[i][0] < -10) {
          tiPositions[i][0] = -10
          tiVelocities[i][0] *= -0.5
        }
        if (tiPositions[i][1] > 10) {
          tiPositions[i][1] = 10
          tiVelocities[i][1] *= -0.5
        }
        if (tiPositions[i][1] < 0) {
          tiPositions[i][1] = 0
          tiVelocities[i][1] *= -0.5
        }
        if (tiPositions[i][2] > 10) {
          tiPositions[i][2] = 10
          tiVelocities[i][2] *= -0.5
        }
        if (tiPositions[i][2] < -10) {
          tiPositions[i][2] = -10
          tiVelocities[i][2] *= -0.5
        }
      }
    })

    await tiInit()
    status.value = 'è¿è¡Œä¸­'
  } catch (error) {
    console.error('Taichi.js åˆå§‹åŒ–å¤±è´¥:', error)
    status.value = 'Taichi.js ä¸å¯ç”¨'
    tiUpdate = null
  }
}

// æ›´æ–°ç²’å­ç³»ç»Ÿ
async function updateParticles() {
  if (!tiUpdate || !particles) return

  const gpuStart = performance.now()

  try {
    await tiBuildGrid()
    await tiComputeForces()
    await tiUpdate()

    const gpuEnd = performance.now()
    gpuTime.value = gpuEnd - gpuStart

    const transferStart = performance.now()
    const posData = await tiPositions.toArray()
    const velData = await tiVelocities.toArray()
    const transferEnd = performance.now()
    transferTime.value = transferEnd - transferStart

    const renderStart = performance.now()
    const positionsAttr = particles.geometry.attributes.position
    const colorsAttr = particles.geometry.attributes.color

    for (let i = 0; i < N; i++) {
      const px = posData[i]?.[0] ?? 0
      const py = posData[i]?.[1] ?? 0
      const pz = posData[i]?.[2] ?? 0
      const vx = velData[i]?.[0] ?? 0
      const vy = velData[i]?.[1] ?? 0
      const vz = velData[i]?.[2] ?? 0

      positionsAttr.setXYZ(i, px, py, pz)

      let r = 0, g = 0.5, b = 1
      const speed = Math.sqrt(vx * vx + vy * vy + vz * vz)

      if (visualMode.value === 'speed') {
        const t = Math.min(speed / 5, 1)
        r = t
        g = 1 - t * 0.5
        b = 1 - t
      } else if (visualMode.value === 'density') {
        const height = py / 10
        r = 1 - height
        g = 0.5
        b = height
      } else {
        r = 0.2 + speed * 0.2
        g = 0.5
        b = 1 - speed * 0.3
      }

      colorsAttr.setXYZ(i, r, g, b)
    }

    positionsAttr.needsUpdate = true
    colorsAttr.needsUpdate = true

    const renderEnd = performance.now()
    renderTime.value = renderEnd - renderStart

  } catch (error) {
    console.error('æ›´æ–°å¤±è´¥:', error)
    status.value = 'é”™è¯¯'
  }
}

// åŠ¨ç”»å¾ªç¯
function animate() {
  const now = performance.now()
  frameCount++

  if (now - lastFrameTime >= 1000) {
    fps.value = frameCount
    frameCount = 0
    lastFrameTime = now
    frameTime.value = 1000 / fps.value
  }

  if (isAnimating.value) {
    updateParticles()
  }

  bounds.visible = showBounds.value

  if (renderer && scene && camera) {
    renderer.render(scene, camera)
  }

  requestAnimationFrame(animate)
}

function toggleAnimation() {
  isAnimating.value = !isAnimating.value
  status.value = isAnimating.value ? 'è¿è¡Œä¸­' : 'å·²æš‚åœ'
}

async function resetSimulation() {
  if (particles) {
    scene.remove(particles)
    if (particles.geometry) particles.geometry.dispose()
    if (particles.material) particles.material.dispose()
  }

  N = parseInt(particleCount.value as string)
  createParticles()
  await initTaichi()
}

function goToPrev() {
  window.location.reload()
}

onMounted(async () => {
  initThreeJS()
  await initTaichi()
  animate()
})

onUnmounted(() => {
  if (particles) {
    scene.remove(particles)
    if (particles.geometry) particles.geometry.dispose()
    if (particles.material) particles.material.dispose()
  }
  if (bounds) {
    scene.remove(bounds)
    if (bounds.geometry) bounds.geometry.dispose()
    if (bounds.material) bounds.material.dispose()
  }
  if (renderer) {
    renderer.dispose()
  }
})
</script>

<style scoped lang="scss">
.lesson-page {
  min-height: 100vh;
  background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
  padding: 80px 30px 30px 30px;
  color: white;
}

.content-area {
  max-width: 900px;
  margin: 0 auto;
}

.lesson-info {
  .lesson-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 30px;

    h2 {
      margin: 0;
      font-size: 32px;
      color: #00ff88;
    }

    .lesson-tag {
      padding: 6px 15px;
      background: rgba(255, 215, 0, 0.2);
      border: 1px solid rgba(255, 215, 0, 0.4);
      border-radius: 20px;
      font-size: 13px;
      color: #ffd700;
    }
  }

  .section {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 25px;
    border: 1px solid rgba(255, 255, 255, 0.08);

    h3 {
      margin: 0 0 15px 0;
      font-size: 22px;
      color: #00aaff;
    }

    p {
      font-size: 15px;
      line-height: 1.7;
      color: rgba(255, 255, 255, 0.85);
      margin-bottom: 15px;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;

      li {
        padding: 8px 0 8px 25px;
        position: relative;
        font-size: 15px;
        line-height: 1.6;
        color: rgba(255, 255, 255, 0.85);

        &:before {
          content: 'â–¸';
          position: absolute;
          left: 0;
          color: #00ff88;
        }
      }
    }
  }

  .highlight-box {
    background: rgba(255, 215, 0, 0.1);
    border-left: 4px solid rgba(255, 215, 0, 0.6);
    padding: 15px 20px;
    border-radius: 8px;
    margin: 20px 0;

    strong {
      color: #ffd700;
      font-size: 16px;
    }

    h4 {
      color: #ffd700;
      margin: 0 0 10px 0;
      font-size: 18px;
    }

    p {
      margin: 10px 0 0 0;
    }

    pre {
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 5px;
      margin-top: 10px;
      overflow-x: auto;

      code {
        font-family: 'Courier New', monospace;
        font-size: 11px;
        line-height: 1.3;
        color: #aaffaa;
      }
    }
  }

  .code-demo {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(0, 255, 136, 0.2);
    border-radius: 12px;
    padding: 20px;

    pre {
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;

      code {
        font-family: 'Courier New', monospace;
        font-size: 10px;
        line-height: 1.4;
        color: #aaffaa;
      }
    }
  }

  .tips {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;

    .tip-card {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(0, 255, 136, 0.2);
      border-radius: 10px;
      padding: 15px;

      h4 {
        margin: 0 0 10px 0;
        font-size: 16px;
        color: #ffd700;
      }

      p {
        margin: 0 0 10px 0;
        font-size: 14px;
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0;

        li {
          padding: 5px 0 5px 20px;
          position: relative;
          font-size: 13px;

          &:before {
            content: 'â€¢';
            position: absolute;
            left: 0;
            color: #00aaff;
          }
        }
      }
    }
  }

  .demo-container {
    background: rgba(0, 50, 100, 0.15);
    border: 1px solid rgba(0, 170, 255, 0.2);
    border-radius: 12px;
    padding: 25px;

    .demo-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
      align-items: center;

      label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;

        select {
          padding: 5px;
          background: rgba(0, 0, 0, 0.3);
          border: 1px solid rgba(0, 255, 136, 0.4);
          border-radius: 5px;
          color: white;
        }
      }

      button {
        padding: 10px 20px;
        background: rgba(0, 255, 136, 0.2);
        border: 1px solid rgba(0, 255, 136, 0.4);
        border-radius: 8px;
        color: #00ff88;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;

        &:hover {
          background: rgba(0, 255, 136, 0.3);
        }
      }
    }

    .demo-canvas-container {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin-bottom: 15px;
      overflow: hidden;
    }

    .demo-info {
      p {
        font-size: 14px;
        margin-bottom: 5px;

        .running { color: #00ff88; font-weight: bold; }
        .paused { color: #ffaa00; font-weight: bold; }
        .error { color: #ff4444; font-weight: bold; }
        .idle { color: rgba(255, 255, 255, 0.7); }
      }
    }
  }
}

.navigation {
  display: flex;
  justify-content: space-between;
  margin-top: 30px;

  .nav-btn {
    padding: 12px 25px;
    background: rgba(0, 170, 255, 0.2);
    border: 1px solid rgba(0, 170, 255, 0.3);
    border-radius: 8px;
    color: #00aaff;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;

    &:hover {
      background: rgba(0, 170, 255, 0.3);
      transform: translateX(-2px);
    }

    &.next:hover {
      transform: translateX(2px);
    }

    &.disabled {
      background: rgba(0, 255, 136, 0.3);
      border-color: rgba(0, 255, 136, 0.4);
      color: #00ff88;
      cursor: default;
    }
  }
}

@media (max-width: 768px) {
  .lesson-page {
    padding: 60px 15px 20px 15px;
  }

  .tips {
    grid-template-columns: 1fr;
  }
}
</style>
